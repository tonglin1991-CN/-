<!DOCTYPE html>
<html lang="zh">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
<meta name="apple-mobile-web-app-capable" content="yes">
<meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
<meta name="apple-mobile-web-app-title" content="SNAKE">
<title>SNAKE</title>
<link href="https://fonts.googleapis.com/css2?family=Orbitron:wght@400;700;900&family=Share+Tech+Mono&display=swap" rel="stylesheet">
<style>
:root {
  --neon-cyan: #00ffe7;
  --neon-pink: #ff2d78;
  --neon-yellow: #ffe600;
  --dark: #030810;
  --dark2: #050d18;
  --grid: rgba(0,255,231,0.04);
  --glow-cyan: 0 0 8px #00ffe7, 0 0 20px #00ffe780, 0 0 40px #00ffe740;
  --glow-pink: 0 0 8px #ff2d78, 0 0 24px #ff2d7880, 0 0 50px #ff2d7840;
}

*, *::before, *::after { margin:0; padding:0; box-sizing:border-box; }

html, body {
  width:100%; height:100%;
  background: var(--dark);
  overflow: hidden;
  touch-action: none;
  -webkit-tap-highlight-color: transparent;
  -webkit-text-size-adjust: 100%;
  font-family: 'Share Tech Mono', monospace;
}

body {
  position: relative;
}

/* ‚îÄ‚îÄ Animated background ‚îÄ‚îÄ */
body::before {
  content: '';
  position: fixed; inset: 0;
  background:
    repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(0,255,231,0.015) 2px, rgba(0,255,231,0.015) 4px),
    repeating-linear-gradient(90deg, transparent, transparent 2px, rgba(0,255,231,0.01) 2px, rgba(0,255,231,0.01) 4px);
  pointer-events: none; z-index: 0;
}

/* scanline overlay */
body::after {
  content: '';
  position: fixed; inset: 0;
  background: repeating-linear-gradient(
    to bottom,
    transparent 0px,
    transparent 3px,
    rgba(0,0,0,0.18) 3px,
    rgba(0,0,0,0.18) 4px
  );
  pointer-events: none; z-index: 100;
  animation: scanMove 8s linear infinite;
}

@keyframes scanMove {
  0%   { background-position: 0 0; }
  100% { background-position: 0 100px; }
}

@keyframes borderPulse {
  0%,100% { border-color: rgba(0,255,231,0.5); box-shadow: 0 0 0 1px rgba(0,255,231,0.1), 0 0 20px rgba(0,255,231,0.15), inset 0 0 30px rgba(0,0,0,0.6); }
  50%      { border-color: rgba(0,255,231,0.9); box-shadow: 0 0 0 1px rgba(0,255,231,0.2), 0 0 32px rgba(0,255,231,0.3), inset 0 0 30px rgba(0,0,0,0.6); }
}

/* ‚îÄ‚îÄ Header ‚îÄ‚îÄ */
.header {
  position: fixed;
  top: 0; left: 0; right: 0;
  display: flex; justify-content: space-between; align-items: center;
  padding: max(env(safe-area-inset-top,0px),4px) 12px 4px;
  z-index: 20;
  background: rgba(3,8,16,0.92);
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
}

.title-wrap { display: flex; flex-direction: column; gap: 1px; }

.title {
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  font-size: 22px;
  letter-spacing: 6px;
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  animation: glitch 6s infinite;
  position: relative;
}

@keyframes glitch {
  0%,94%,100% { text-shadow: var(--glow-cyan); transform: translate(0); }
  95% { text-shadow: -2px 0 var(--neon-pink), 2px 0 var(--neon-cyan); transform: translate(-1px, 0); }
  96% { text-shadow: 2px 0 var(--neon-pink), -2px 0 var(--neon-cyan); transform: translate(2px, 0); }
  97% { text-shadow: var(--glow-cyan); transform: translate(0); }
  98% { text-shadow: -1px 0 var(--neon-yellow); transform: translate(1px, 0); }
  99% { text-shadow: var(--glow-cyan); transform: translate(0); }
}

.subtitle {
  font-size: 8px;
  letter-spacing: 5px;
  color: rgba(0,255,231,0.35);
  text-transform: uppercase;
}

.score-block { text-align: right; }

.score-label {
  font-size: 8px;
  letter-spacing: 4px;
  color: rgba(0,255,231,0.4);
  text-transform: uppercase;
}

.score-value {
  font-family: 'Orbitron', sans-serif;
  font-weight: 700;
  font-size: 30px;
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  letter-spacing: 2px;
  line-height: 1;
  display: inline-block;
  transition: transform 0.1s ease;
}

.score-value.pop {
  transform: scale(1.4);
  color: var(--neon-yellow);
  text-shadow: 0 0 10px var(--neon-yellow), 0 0 30px var(--neon-yellow);
}

/* ‚îÄ‚îÄ HUD extras ‚îÄ‚îÄ */
.hud-right { display:flex; flex-direction:column; align-items:flex-end; gap:3px; }
.hud-row { display:flex; align-items:center; gap:6px; justify-content:flex-end; }
.hud-row-meta { margin-top:1px; }
.meta-item { display:flex; align-items:center; gap:3px; }
.meta-label { font-size:7px; letter-spacing:2px; color:rgba(0,255,231,0.35); }
.meta-val { font-family:'Orbitron',sans-serif; font-size:11px; color:var(--neon-cyan);
  text-shadow:0 0 6px var(--neon-cyan); letter-spacing:1px; }
.lives-wrap { display:flex; gap:3px; align-items:center; }
.heart { font-size:13px; color:var(--neon-pink); text-shadow:0 0 8px var(--neon-pink);
  transition:opacity 0.3s, transform 0.3s; }
.heart.lost { opacity:0.15; transform:scale(0.7); color:#555; text-shadow:none; }

/* ‚îÄ‚îÄ Level clear overlay ‚îÄ‚îÄ */
#level-clear {
  position:absolute; inset:0;
  background:rgba(3,8,16,0.93);
  display:none; flex-direction:column;
  justify-content:center; align-items:center; gap:14px;
  z-index:30;
  backdrop-filter:blur(4px);
  -webkit-backdrop-filter:blur(4px);
}
#level-clear.show { display:flex; }
.lc-title {
  font-family:'Orbitron',sans-serif; font-weight:900;
  font-size:26px; letter-spacing:6px;
  color:var(--neon-yellow);
  text-shadow:0 0 12px var(--neon-yellow),0 0 40px var(--neon-yellow80);
  animation:glitch 3s infinite;
}
.lc-sub { font-size:10px; letter-spacing:5px; color:rgba(0,255,231,0.5); }
.lc-next-btn {
  background:none; border:1px solid var(--neon-yellow);
  color:var(--neon-yellow); font-family:'Orbitron',sans-serif;
  font-size:10px; font-weight:700; letter-spacing:5px;
  padding:12px 30px; cursor:pointer; text-transform:uppercase;
  text-shadow:0 0 8px var(--neon-yellow);
  box-shadow:0 0 14px rgba(255,230,0,0.2);
  -webkit-appearance:none; border-radius:0;
}
.lc-next-btn:active { background:rgba(255,230,0,0.12); }

/* ‚îÄ‚îÄ Canvas ‚îÄ‚îÄ */
.canvas-wrap { position: fixed; left: 50%; transform: translateX(-50%); z-index: 10; }

canvas {
  display: block;
  border: 1px solid rgba(0,255,231,0.5);
  box-shadow:
    0 0 0 1px rgba(0,255,231,0.1),
    0 0 20px rgba(0,255,231,0.15),
    inset 0 0 30px rgba(0,0,0,0.6);
  animation: borderPulse 2s ease-in-out infinite;
  image-rendering: pixelated;
  image-rendering: crisp-edges;
}

/* corner decorations */
.canvas-wrap::before, .canvas-wrap::after,
.corner-bl, .corner-br {
  content: '';
  position: absolute;
  width: 14px; height: 14px;
  border-color: var(--neon-cyan);
  border-style: solid;
  opacity: 0.7;
  z-index: 2;
}
.canvas-wrap::before { top:-1px; left:-1px; border-width: 2px 0 0 2px; }
.canvas-wrap::after  { top:-1px; right:-1px; border-width: 2px 2px 0 0; }
.corner-bl { bottom:-1px; left:-1px; border-width: 0 0 2px 2px; }
.corner-br { bottom:-1px; right:-1px; border-width: 0 2px 2px 0; }

/* ‚îÄ‚îÄ Overlay ‚îÄ‚îÄ */
.overlay {
  position: absolute; inset: 0;
  background: rgba(3,8,16,0.92);
  display: flex; flex-direction: column;
  justify-content: center; align-items: center; gap: 16px;
  backdrop-filter: blur(4px);
  -webkit-backdrop-filter: blur(4px);
  z-index: 20;
}

.overlay-title {
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  font-size: 28px;
  letter-spacing: 8px;
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  animation: glitch 4s infinite;
}

.overlay-sub {
  font-size: 9px;
  letter-spacing: 5px;
  color: rgba(0,255,231,0.3);
  text-transform: uppercase;
}

.final-score {
  font-size: 10px;
  letter-spacing: 4px;
  color: rgba(0,255,231,0.4);
  display: none;
}
.final-score span {
  font-family: 'Orbitron', sans-serif;
  font-size: 18px;
  color: var(--neon-pink);
  text-shadow: var(--glow-pink);
  letter-spacing: 2px;
}

.start-btn {
  position: relative;
  background: transparent;
  border: 1px solid var(--neon-cyan);
  color: var(--neon-cyan);
  font-family: 'Orbitron', sans-serif;
  font-size: 10px;
  font-weight: 700;
  letter-spacing: 5px;
  padding: 13px 36px;
  cursor: pointer;
  text-transform: uppercase;
  text-shadow: 0 0 8px var(--neon-cyan);
  box-shadow: 0 0 12px rgba(0,255,231,0.2), inset 0 0 12px rgba(0,255,231,0.05);
  transition: all 0.2s;
  -webkit-appearance: none;
  border-radius: 0;
  overflow: hidden;
}

.start-btn::before {
  content: '';
  position: absolute; inset: 0;
  background: var(--neon-cyan);
  opacity: 0;
  transition: opacity 0.2s;
}

.start-btn:active::before { opacity: 0.15; }
.start-btn:active {
  box-shadow: 0 0 24px rgba(0,255,231,0.5), inset 0 0 20px rgba(0,255,231,0.1);
}

/* ‚îÄ‚îÄ Pause button ‚Äî fixed top-left corner ‚îÄ‚îÄ */
#pause-btn {
  position: fixed;
  top: max(env(safe-area-inset-top,0px), 8px);
  left: 10px;
  width: 40px; height: 40px;
  border-radius: 50%;
  background: rgba(10,10,20,0.85);
  border: 1.5px solid rgba(255,230,0,0.6);
  display: flex; flex-direction: column;
  justify-content: center; align-items: center; gap: 1px;
  cursor: pointer;
  user-select: none; -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  z-index: 80;
  box-shadow: 0 0 12px rgba(255,230,0,0.25), inset 0 0 8px rgba(0,0,0,0.5);
  transition: background 0.1s, border-color 0.1s, box-shadow 0.1s;
}
#pause-btn:active, #pause-btn.pressed {
  background: rgba(255,230,0,0.22);
  border-color: rgba(255,230,0,1);
  box-shadow: 0 0 22px rgba(255,230,0,0.65);
}
#pause-btn svg { width: 16px; height: 16px; fill: var(--neon-yellow); opacity: 0.92; filter: drop-shadow(0 0 5px var(--neon-yellow)); }
#pause-btn:active svg { opacity: 1; }
.pause-label {
  font-family: 'Orbitron', sans-serif;
  font-size: 5px; letter-spacing: 1px;
  color: var(--neon-yellow); opacity: 0.7;
}
.header-left { display: flex; align-items: center; }

/* status bar removed */

/* ‚îÄ‚îÄ Power-up status bars ‚îÄ‚îÄ */
#powerup-bar {
  position: fixed;
  bottom: max(env(safe-area-inset-bottom,0px), 10px);
  left: 10px;
  display: flex; gap: 8px; align-items: flex-end;
  z-index: 60; pointer-events: none;
}
.pu-item {
  display: flex; align-items: center; gap: 4px;
  background: rgba(3,8,16,0.85);
  border-radius: 20px; padding: 3px 10px 3px 6px;
  border: 1px solid transparent;
  opacity: 0; transform: scale(0.8);
  transition: opacity 0.3s, transform 0.3s, border-color 0.3s;
  font-family: 'Orbitron', sans-serif; font-size: 9px; letter-spacing: 2px;
}
.pu-item.active { opacity: 1; transform: scale(1); }
#pu-ghost { border-color: rgba(100,200,255,0.6); color: #64c8ff; }
#pu-invincible { border-color: rgba(255,215,0,0.8); color: #ffd700; }
#pu-transparent-bar { color: #64c8ff; }
#pu-invincible-bar  { color: #ffd700; }
.pu-icon { font-size: 13px; }
.pu-timer-track {
  width: 40px; height: 4px; background: rgba(255,255,255,0.1);
  border-radius: 2px; overflow: hidden;
}
.pu-timer-fill {
  height: 100%; border-radius: 2px;
  transition: width 0.1s linear;
}
#pu-ghost .pu-timer-fill { background: #64c8ff; box-shadow: 0 0 6px #64c8ff; }
#pu-invincible .pu-timer-fill { background: #ffd700; box-shadow: 0 0 6px #ffd700; }

/* ‚îÄ‚îÄ D-pad ‚îÄ‚îÄ */
#dpad-wrap {
  position: fixed;
  bottom: max(env(safe-area-inset-bottom,0px), 2px);
  left: 0; right: 0;
  z-index: 50;
  pointer-events: none;
  /* height set by JS */
}
#dpad {
  position: relative;
  margin: 0 auto;
  pointer-events: all;
  border-radius: 24px;
  overflow: hidden;
  background: rgba(0,255,231,0.025);
  border: 1px solid rgba(0,255,231,0.12);
  /* width/height set by JS */
}
.dp-btn {
  position: absolute;
  top: 0; left: 0;
  cursor: pointer;
  user-select: none; -webkit-user-select: none;
  -webkit-tap-highlight-color: transparent;
  background: transparent;
  border: none;
  transition: background 0.06s;
  /* width/height/clip-path set by JS */
}
.dp-btn svg {
  position: absolute;
  fill: var(--neon-cyan);
  opacity: 0.85;
  filter: drop-shadow(0 0 6px var(--neon-cyan));
  pointer-events: none;
  /* size/position set by JS */
}
.dp-btn:active svg, .dp-btn.pressed svg { opacity: 1; }
.dp-btn:active, .dp-btn.pressed { background: rgba(0,255,231,0.18); }
#dpad::before {
  content: '';
  position: absolute; inset: 0;
  background:
    linear-gradient(to bottom right, transparent calc(50% - 0.7px), rgba(0,255,231,0.22) calc(50% - 0.7px), rgba(0,255,231,0.22) calc(50% + 0.7px), transparent calc(50% + 0.7px)),
    linear-gradient(to bottom left,  transparent calc(50% - 0.7px), rgba(0,255,231,0.22) calc(50% - 0.7px), rgba(0,255,231,0.22) calc(50% + 0.7px), transparent calc(50% + 0.7px));
  pointer-events: none; z-index: 3;
}

/* ‚îÄ‚îÄ Particle canvas ‚îÄ‚îÄ */
#particles {
  position: fixed; inset: 0;
  pointer-events: none; z-index: 1;
}

/* ‚îÄ‚îÄ Tier banner ‚îÄ‚îÄ */
#tier-banner {
  position: fixed;
  top: 38%;
  left: 50%;
  transform: translateX(-50%) scale(0.6);
  font-family: 'Orbitron', sans-serif;
  font-weight: 900;
  font-size: 22px;
  letter-spacing: 6px;
  color: var(--neon-cyan);
  text-shadow: var(--glow-cyan);
  pointer-events: none;
  z-index: 200;
  opacity: 0;
  white-space: nowrap;
  transition: none;
}

#tier-banner.show {
  animation: tierReveal 2.2s ease forwards;
}

@keyframes tierReveal {
  0%   { opacity:0; transform: translateX(-50%) scale(0.5); }
  15%  { opacity:1; transform: translateX(-50%) scale(1.1); }
  30%  { opacity:1; transform: translateX(-50%) scale(1.0); }
  70%  { opacity:1; transform: translateX(-50%) scale(1.0); }
  100% { opacity:0; transform: translateX(-50%) scale(0.9); }
}
</style>
</head>
<body>

<canvas id="particles"></canvas>

<div class="header" id="header">
  <div class="title-wrap">
    <div class="title">SNAKE</div>
    <div class="subtitle" id="level-label">LV.01 // STAGE 1</div>
  </div>
  <div class="hud-right">
    <div class="hud-row">
      <div class="score-label">// score</div>
      <div class="score-value" id="score">000</div>
    </div>
    <div class="hud-row hud-row-meta">
      <div class="meta-item">
        <span class="meta-label">LV</span>
        <span class="meta-val" id="level-num">01</span>
      </div>
      <div class="lives-wrap" id="lives-wrap">
        <span class="heart">‚ô•</span><span class="heart">‚ô•</span><span class="heart">‚ô•</span><span class="heart">‚ô•</span><span class="heart">‚ô•</span>
      </div>
      <div class="meta-item">
        <span class="meta-label">GOAL</span>
        <span class="meta-val" id="goal-progress">000/120</span>
      </div>
    </div>
  </div>
</div>

<button id="pause-btn">
  <svg id="pause-icon" viewBox="0 0 24 24">
    <rect x="6" y="5" width="4" height="14" rx="1"/>
    <rect x="14" y="5" width="4" height="14" rx="1"/>
  </svg>
  <span class="pause-label" id="pause-label">II</span>
</button>

<div class="canvas-wrap" id="canvas-wrap">
  <div class="corner-bl"></div>
  <div class="corner-br"></div>
  <canvas id="game"></canvas>
  <div class="overlay" id="overlay">
    <div class="overlay-title">SNAKE</div>
    <div class="overlay-sub" id="overlay-sub">cyberpunk edition</div>
    <div class="final-score" id="final-score">
      FINAL&nbsp;&nbsp;<span id="final-val">0</span>
    </div>
    <button class="start-btn" id="start-btn">[ START ]</button>
  </div>
  <div id="level-clear">
    <div class="lc-title" id="lc-title">STAGE CLEAR</div>
    <div class="lc-sub" id="lc-sub">// NEXT LEVEL</div>
    <button class="lc-next-btn" id="lc-next-btn">[ NEXT STAGE ]</button>
  </div>
</div>

<div id="tier-banner"></div>

<div id="powerup-bar">
  <div class="pu-item" id="pu-ghost">
    <span class="pu-icon">üëª</span>
    <span>ÈÄèÊòé</span>
    <div class="pu-timer-track"><div class="pu-timer-fill" id="pu-transparent-bar"></div></div>
  </div>
  <div class="pu-item" id="pu-invincible">
    <span class="pu-icon">üêâ</span>
    <span>Êó†Êïå</span>
    <div class="pu-timer-track"><div class="pu-timer-fill" id="pu-invincible-bar"></div></div>
  </div>
</div>





<div id="dpad-wrap">
  <div id="dpad">
    <!-- UP -->
    <button class="dp-btn" id="dp-up" data-dir="up">
      <svg viewBox="0 0 24 24"><path d="M12 4l-9 10h18z"/></svg>
    </button>
    <!-- DOWN -->
    <button class="dp-btn" id="dp-down" data-dir="down">
      <svg viewBox="0 0 24 24"><path d="M12 20l9-10H3z"/></svg>
    </button>
    <!-- LEFT -->
    <button class="dp-btn" id="dp-left" data-dir="left">
      <svg viewBox="0 0 24 24"><path d="M4 12l10-9v18z"/></svg>
    </button>
    <!-- RIGHT -->
    <button class="dp-btn" id="dp-right" data-dir="right">
      <svg viewBox="0 0 24 24"><path d="M20 12l-10 9V3z"/></svg>
    </button>
  </div>
</div>

<script>
// ‚îÄ‚îÄ Particle background ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const pc = document.getElementById('particles');
const pctx = pc.getContext('2d');
let particles = [];

function resizeParticles() {
  pc.width  = window.innerWidth;
  pc.height = window.innerHeight;
}
resizeParticles();

for (let i = 0; i < 35; i++) {
  particles.push({
    x: Math.random() * window.innerWidth,
    y: Math.random() * window.innerHeight,
    size: Math.random() * 1.5 + 0.3,
    speedY: -(Math.random() * 0.4 + 0.1),
    alpha: Math.random() * 0.5 + 0.1,
  });
}

function animateParticles() {
  pctx.clearRect(0, 0, pc.width, pc.height);
  particles.forEach(p => {
    p.y += p.speedY;
    if (p.y < -5) p.y = pc.height + 5;
    pctx.beginPath();
    pctx.arc(p.x, p.y, p.size, 0, Math.PI*2);
    pctx.fillStyle = `rgba(0,255,231,${p.alpha})`;
    pctx.fill();
  });
  requestAnimationFrame(animateParticles);
}
animateParticles();

// ‚îÄ‚îÄ Canvas sizing ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const canvas   = document.getElementById('game');
const ctx      = canvas.getContext('2d');
const headerEl = document.getElementById('header');
const CELL = 20;
let COLS, ROWS;

function resizeCanvas() {
  const W = window.innerWidth;
  const H = window.innerHeight;
  const headerH = headerEl.getBoundingClientRect().height || 52;
  // safe area bottom (iPhone notch etc)
  const safeB = parseInt(
    getComputedStyle(document.documentElement).getPropertyValue('padding-bottom') || 0
  ) || 0;
  const bottomGap = Math.max(safeB, 2);

  // ‚îÄ‚îÄ D-pad: square, fills full screen width up to 320px ‚îÄ‚îÄ
  const dpadSize = Math.min(W, 320);
  const dpadWrap = document.getElementById('dpad-wrap');
  const dpadEl   = document.getElementById('dpad');
  dpadEl.style.width  = dpadSize + 'px';
  dpadEl.style.height = dpadSize + 'px';
  dpadWrap.style.height = (dpadSize + bottomGap) + 'px';

  // Wedge clip-paths centred in the square
  const S = dpadSize;
  const cx = S/2, cy = S/2;
  const inset = S * 0.30; // inner trapezoid edge distance from centre
  const svgSz = Math.round(S * 0.19);
  const wedges = {
    'dp-up':    {
      clip:`polygon(0 0,${S}px 0,${cx+inset}px ${cy-inset}px,${cx-inset}px ${cy-inset}px)`,
      sx: cx - svgSz/2, sy: cy*0.28
    },
    'dp-down':  {
      clip:`polygon(${cx-inset}px ${cy+inset}px,${cx+inset}px ${cy+inset}px,${S}px ${S}px,0 ${S}px)`,
      sx: cx - svgSz/2, sy: cy + cy*0.53
    },
    'dp-left':  {
      clip:`polygon(0 0,${cx-inset}px ${cy-inset}px,${cx-inset}px ${cy+inset}px,0 ${S}px)`,
      sx: cx*0.22, sy: cy - svgSz/2
    },
    'dp-right': {
      clip:`polygon(${cx+inset}px ${cy-inset}px,${S}px 0,${S}px ${S}px,${cx+inset}px ${cy+inset}px)`,
      sx: cx + cx*0.61, sy: cy - svgSz/2
    },
  };
  Object.entries(wedges).forEach(([id, w]) => {
    const btn = document.getElementById(id);
    btn.style.width      = S + 'px';
    btn.style.height     = S + 'px';
    btn.style.clipPath   = w.clip;
    const svg = btn.querySelector('svg');
    svg.style.width  = svgSz + 'px';
    svg.style.height = svgSz + 'px';
    svg.style.left   = w.sx + 'px';
    svg.style.top    = w.sy + 'px';
  });

  // ‚îÄ‚îÄ Canvas: fill space between header and dpad ‚îÄ‚îÄ
  const dpadH    = dpadSize + bottomGap;
  const availH   = H - headerH - dpadH;
  const maxSide  = Math.min(W, availH, 900);
  const cells    = Math.floor(maxSide / CELL);
  const size     = cells * CELL;
  COLS = cells; ROWS = cells;
  canvas.width  = size; canvas.height = size;
  canvas.style.width  = size + 'px';
  canvas.style.height = size + 'px';
  document.getElementById('overlay').style.cssText = `width:${size}px;height:${size}px`;
  const canvasWrap = document.getElementById('canvas-wrap');
  // vertically centre in available space
  const topPos = headerH + Math.max(0, Math.floor((availH - size) / 2));
  canvasWrap.style.top = topPos + 'px';
}
resizeCanvas();

// ‚îÄ‚îÄ Audio ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let AC;
function getAC() {
  if (!AC) AC = new (window.AudioContext || window.webkitAudioContext)();
  return AC;
}
function resumeAC() { const a = getAC(); if (a.state==='suspended') a.resume(); }

// ‚îÄ‚îÄ 8-bit BGM: 10 unique level tracks ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Notes: C4=261.63 D4=293.66 E4=329.63 F4=349.23 G4=392 A4=440 B4=493.88
// C5=523.25 D5=587.33 E5=659.25 F5=698.46 G5=783.99 A5=880 B5=987.77
const N = {
  C3:130.81,D3:146.83,E3:164.81,G3:196,A3:220,
  C4:261.63,D4:293.66,E4:329.63,F4:349.23,G4:392,A4:440,B4:493.88,
  C5:523.25,D5:587.33,E5:659.25,F5:698.46,G5:783.99,A5:880,B5:987.77,
  C6:1046.5,_:0
};
const LEVEL_TRACKS = [
  // LV1 AWAKENING ‚Äî gentle C major waltz
  { bpm:280, wave:'square', vol:0.038,
    melody:[N.C4,N.E4,N.G4,N.C5,N.G4,N.E4, N.D4,N.F4,N.A4,N.D5,N.A4,N.F4,
            N.E4,N.G4,N.B4,N.E5,N.B4,N.G4, N.C4,N.E4,N.G4,N.C5,N.G4,N.C4],
    bass: [N.C3,N._,N._,N.G3,N._,N._, N.D3,N._,N._,N.A3,N._,N._,
           N.E3,N._,N._,N.B3,N._,N._, N.C3,N._,N._,N.G3,N._,N._] },
  // LV2 GRID ECHO ‚Äî bouncy D minor funk
  { bpm:300, wave:'square', vol:0.038,
    melody:[N.D4,N.F4,N.A4,N.D5,N.A4,N.F4,N.D4,N._, N.C4,N.E4,N.G4,N.C5,N.G4,N.E4,N.C4,N._,
            N.A3,N.C4,N.E4,N.A4,N.E4,N.C4,N.A3,N._, N.G3,N.B3,N.D4,N.G4,N.D4,N.B3,N.G3,N._],
    bass: [N.D3,N._,N.A3,N._,N.D3,N._,N.A3,N._, N.C3,N._,N.G3,N._,N.C3,N._,N.G3,N._,
           N.A3,N._,N.E3,N._,N.A3,N._,N.E3,N._, N.G3,N._,N.D3,N._,N.G3,N._,N.D3,N._] },
  // LV3 STATIC ‚Äî syncopated E minor groove
  { bpm:320, wave:'square', vol:0.036,
    melody:[N.E4,N._,N.G4,N.B4,N._,N.E5,N.B4,N.G4, N.D4,N._,N.F4,N.A4,N._,N.D5,N.A4,N.F4,
            N.C4,N._,N.E4,N.G4,N._,N.C5,N.G4,N.E4, N.B3,N._,N.D4,N.F4,N._,N.B4,N.F4,N.D4],
    bass: [N.E3,N._,N._,N.B3,N._,N._,N.E3,N._, N.D3,N._,N._,N.A3,N._,N._,N.D3,N._,
           N.C3,N._,N._,N.G3,N._,N._,N.C3,N._, N.B3,N._,N._,N.E3,N._,N._,N.B3,N._] },
  // LV4 LABYRINTH ‚Äî dark A minor march
  { bpm:260, wave:'sawtooth', vol:0.028,
    melody:[N.A4,N.G4,N.F4,N.E4,N.D4,N.E4,N.F4,N._, N.G4,N.F4,N.E4,N.D4,N.C4,N.D4,N.E4,N._,
            N.F4,N.E4,N.D4,N.C4,N.B3,N.C4,N.D4,N._, N.E4,N.A4,N.G4,N.F4,N.E4,N._,N.A4,N._],
    bass: [N.A3,N._,N.E3,N._,N.A3,N._,N.E3,N._, N.G3,N._,N.D3,N._,N.G3,N._,N.D3,N._,
           N.F3,N._,N.C3,N._,N.F3,N._,N.C3,N._, N.E3,N._,N.A3,N._,N.E3,N._,N.A3,N._] },
  // LV5 FRACTURE ‚Äî fast G major chase
  { bpm:360, wave:'square', vol:0.034,
    melody:[N.G4,N.A4,N.B4,N.C5,N.D5,N.C5,N.B4,N.A4, N.G4,N.B4,N.D5,N.G5,N.D5,N.B4,N.G4,N._,
            N.A4,N.C5,N.E5,N.A5,N.E5,N.C5,N.A4,N._, N.G4,N.B4,N.D5,N.F5,N.E5,N.D5,N.C5,N.B4],
    bass: [N.G3,N._,N.D3,N._,N.G3,N._,N.D3,N._, N.G3,N._,N.B3,N._,N.D3,N._,N.G3,N._,
           N.A3,N._,N.E3,N._,N.A3,N._,N.E3,N._, N.G3,N._,N.D3,N._,N.B3,N._,N.G3,N._] },
  // LV6 VORTEX ‚Äî swirling C minor tension
  { bpm:340, wave:'square', vol:0.034,
    melody:[N.C5,N.B4,N.A4,N.G4,N.F4,N.E4,N.D4,N.C4, N.D4,N.E4,N.F4,N.G4,N.A4,N.B4,N.C5,N._,
            N.G4,N.F4,N.E4,N.D4,N.C4,N.D4,N.E4,N.F4, N.G4,N.A4,N.G4,N.F4,N.E4,N._,N.C5,N._],
    bass: [N.C3,N._,N.G3,N._,N.C3,N._,N.G3,N._, N.D3,N._,N.A3,N._,N.D3,N._,N.A3,N._,
           N.G3,N._,N.C3,N._,N.G3,N._,N.C3,N._, N.E3,N._,N.G3,N._,N.C3,N._,N.G3,N._] },
  // LV7 NEXUS ‚Äî jazzy F major with swing feel
  { bpm:310, wave:'triangle', vol:0.045,
    melody:[N.F4,N.A4,N.C5,N.F5,N.E5,N.D5,N.C5,N.A4, N.G4,N.B4,N.D5,N.G5,N.F5,N.E5,N.D5,N.B4,
            N.A4,N.C5,N.E5,N.A5,N.G5,N.F5,N.E5,N.C5, N.F4,N.A4,N.C5,N.E5,N.F5,N._,N.F4,N._],
    bass: [N.F3,N._,N.C3,N._,N.F3,N._,N.A3,N._, N.G3,N._,N.D3,N._,N.G3,N._,N.B3,N._,
           N.A3,N._,N.E3,N._,N.A3,N._,N.C3,N._, N.F3,N._,N.C3,N._,N.F3,N._,N.F3,N._] },
  // LV8 PURGATORY ‚Äî ominous B dim chromatic descent
  { bpm:290, wave:'sawtooth', vol:0.026,
    melody:[N.B4,N.A4,N.G4,N.F4,N.E4,N.D4,N.C4,N.B3, N.C4,N.D4,N.E4,N.F4,N.G4,N.A4,N.B4,N._,
            N.A4,N.G4,N.F4,N.E4,N.D4,N.C4,N.B3,N.A3, N.G3,N.A3,N.B3,N.C4,N.D4,N.E4,N.B4,N._],
    bass: [N.B3,N._,N.F3,N._,N.B3,N._,N.F3,N._, N.C3,N._,N.G3,N._,N.C3,N._,N.G3,N._,
           N.A3,N._,N.E3,N._,N.A3,N._,N.E3,N._, N.G3,N._,N.D3,N._,N.G3,N._,N.B3,N._] },
  // LV9 PHANTOM ‚Äî eerie A minor with arpeggios
  { bpm:380, wave:'square', vol:0.032,
    melody:[N.A5,N.E5,N.C5,N.A4,N.E4,N.C4,N.A3,N._, N.G5,N.D5,N.B4,N.G4,N.D4,N.B3,N.G3,N._,
            N.F5,N.C5,N.A4,N.F4,N.C4,N.A3,N.F3,N._, N.E5,N.B4,N.G4,N.E4,N.B3,N.G3,N.E3,N._],
    bass: [N.A3,N._,N._,N.E3,N._,N._,N.A3,N._, N.G3,N._,N._,N.D3,N._,N._,N.G3,N._,
           N.F3,N._,N._,N.C3,N._,N._,N.F3,N._, N.E3,N._,N._,N.B3,N._,N._,N.E3,N._] },
  // LV10 OBLIVION ‚Äî frantic D minor boss fight
  { bpm:420, wave:'square', vol:0.032,
    melody:[N.D5,N.C5,N.B4,N.A4,N.G4,N.F4,N.E4,N.D4, N.E4,N.F4,N.G4,N.A4,N.B4,N.C5,N.D5,N._,
            N.A4,N.G4,N.F4,N.E4,N.D4,N.E4,N.F4,N.G4, N.A5,N.G5,N.F5,N.E5,N.D5,N.C5,N.D5,N._],
    bass: [N.D3,N._,N.A3,N._,N.D3,N._,N.A3,N._, N.E3,N._,N.B3,N._,N.E3,N._,N.B3,N._,
           N.F3,N._,N.C3,N._,N.F3,N._,N.C3,N._, N.D3,N._,N.A3,N._,N.D3,N._,N.A3,N._] },
];

let bgInt = null, bgStep = 0, bgTrack = null;

function startBGM(lvlIdx) {
  stopBGM();
  bgStep = 0;
  bgTrack = LEVEL_TRACKS[Math.min(lvlIdx, LEVEL_TRACKS.length-1)];
  const intervalMs = Math.round(60000 / bgTrack.bpm);
  bgInt = setInterval(() => {
    const ac = getAC();
    const mel = bgTrack.melody[bgStep % bgTrack.melody.length];
    const bas = bgTrack.bass[bgStep % bgTrack.bass.length];
    const now = ac.currentTime;
    const dur = intervalMs / 1000 * 0.85;
    // melody voice
    if (mel > 0) {
      const osc = ac.createOscillator(), g = ac.createGain();
      osc.type = bgTrack.wave;
      osc.frequency.value = mel;
      g.gain.setValueAtTime(bgTrack.vol, now);
      g.gain.exponentialRampToValueAtTime(0.0001, now + dur);
      osc.connect(g); g.connect(ac.destination);
      osc.start(now); osc.stop(now + dur);
    }
    // bass voice
    if (bas > 0) {
      const osc2 = ac.createOscillator(), g2 = ac.createGain();
      osc2.type = 'triangle';
      osc2.frequency.value = bas;
      g2.gain.setValueAtTime(bgTrack.vol * 0.6, now);
      g2.gain.exponentialRampToValueAtTime(0.0001, now + dur * 1.2);
      osc2.connect(g2); g2.connect(ac.destination);
      osc2.start(now); osc2.stop(now + dur * 1.2);
    }
    bgStep++;
  }, intervalMs);
}

function stopBGM() { if (bgInt) { clearInterval(bgInt); bgInt = null; } }

function playEat() {
  const ac = getAC();
  [500, 750, 1100].forEach((freq, i) => {
    const osc = ac.createOscillator(), g = ac.createGain();
    osc.type = 'square'; osc.frequency.value = freq;
    const t = ac.currentTime + i * 0.05;
    g.gain.setValueAtTime(0.12, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.1);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t + 0.1);
  });
}

function playDie() {
  stopBGM();
  const ac = getAC();
  [350, 250, 160, 80].forEach((freq, i) => {
    const osc = ac.createOscillator(), g = ac.createGain();
    osc.type = 'sawtooth'; osc.frequency.value = freq;
    const t = ac.currentTime + i * 0.13;
    g.gain.setValueAtTime(0.16, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.2);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t + 0.2);
  });
}

// ‚îÄ‚îÄ Snake color themes ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each tier: { name, head, body(t) => color string, glow, shadow, special }
const SNAKE_TIERS = [
  { // 0-9: Cyan (default)
    name: 'CYBER',
    head:   ()=>'#00ffe7',
    body:   (t)=>`rgba(${Math.round(t*20)},${Math.round(255-t*80)},${Math.round(231-t*60)},${1-t*0.65})`,
    glow:   '#00ffe7',
    blur:   14,
    special: false,
  },
  { // 10-19: Toxic Green
    name: 'TOXIC',
    head:   ()=>'#39ff14',
    body:   (t)=>`rgba(${Math.round(57-t*40)},${Math.round(255-t*60)},${Math.round(20+t*10)},${1-t*0.65})`,
    glow:   '#39ff14',
    blur:   16,
    special: false,
  },
  { // 20-29: Lava Orange
    name: 'LAVA',
    head:   ()=>'#ff6200',
    body:   (t)=>`rgba(${Math.round(255-t*30)},${Math.round(98-t*70)},${Math.round(t*10)},${1-t*0.65})`,
    glow:   '#ff6200',
    blur:   18,
    special: false,
  },
  { // 30-39: Electric Purple
    name: 'PLASMA',
    head:   ()=>'#bf00ff',
    body:   (t)=>`rgba(${Math.round(191-t*50)},${Math.round(t*20)},${Math.round(255-t*60)},${1-t*0.65})`,
    glow:   '#bf00ff',
    blur:   18,
    special: false,
  },
  { // 40-49: Blood Red
    name: 'BLOOD',
    head:   ()=>'#ff1a1a',
    body:   (t)=>`rgba(${Math.round(255-t*40)},${Math.round(26-t*20)},${Math.round(26-t*20)},${1-t*0.65})`,
    glow:   '#ff1a1a',
    blur:   20,
    special: false,
  },
  { // 50-59: Ice Blue
    name: 'ICE',
    head:   ()=>'#a8f0ff',
    body:   (t)=>`rgba(${Math.round(168-t*30)},${Math.round(240-t*50)},${255},${1-t*0.6})`,
    glow:   '#a8f0ff',
    blur:   22,
    special: false,
  },
  { // 60-69: Solar Flare ‚Äî gradient head cycles hue
    name: 'SOLAR',
    head:   ()=>`hsl(${(Date.now()/10)%360},100%,60%)`,
    body:   (t)=>`hsla(${((Date.now()/10)+t*120)%360},100%,${Math.round(55-t*20)}%,${1-t*0.6})`,
    glow:   '#ffaa00',
    blur:   24,
    special: false,
  },
  { // 70-79: Venom ‚Äî animated black/green
    name: 'VENOM',
    head:   ()=>'#00ff88',
    body:   (t)=>`rgba(${Math.round(t*10)},${Math.round(255-t*100)},${Math.round(136-t*80)},${1-t*0.6})`,
    glow:   '#00ff88',
    blur:   20,
    special: false,
  },
  { // 80-89: Neon Rainbow ‚Äî each segment different hue
    name: 'RAINBOW',
    head:   ()=>`hsl(${(Date.now()/8)%360},100%,65%)`,
    body:   (t)=>`hsla(${((Date.now()/8)+t*200)%360},100%,60%,${1-t*0.55})`,
    glow:   '#ffffff',
    blur:   26,
    special: false,
  },
  { // 90-99: VOID ‚Äî deep dark with white hot core
    name: 'VOID',
    head:   ()=>'#ffffff',
    body:   (t)=>`rgba(${Math.round(180-t*170)},${Math.round(180-t*170)},${Math.round(220-t*200)},${1-t*0.55})`,
    glow:   '#ffffff',
    blur:   28,
    special: false,
  },
  { // 100+: GOLDEN BOA üêç ‚Äî ultra spectacular
    name: 'GOLDEN BOA',
    head:   ()=>{
      // shimmering gold head that pulses between deep gold and bright white-gold
      const t2 = Date.now()/400;
      const l = 55 + Math.sin(t2)*15;
      return `hsl(45,100%,${l}%)`;
    },
    body:   (t,i)=>{
      // rich alternating scales: bright gold / dark amber, with time shimmer
      const shimmer = Math.sin(Date.now()/300 + i*0.4) * 0.5 + 0.5;
      const even = Math.floor(i/2)%2===0;
      // even segments: bright gold with shimmer highlight
      // odd segments: deep amber-brown
      if (even) {
        const r = Math.round(255);
        const g = Math.round(180 + shimmer*35);
        const b = Math.round(0 + shimmer*20);
        return `rgba(${r},${g},${b},${1-t*0.35})`;
      } else {
        const r = Math.round(180 + shimmer*20);
        const g = Math.round(120 + shimmer*20);
        const b = 0;
        return `rgba(${r},${g},${b},${1-t*0.4})`;
      }
    },
    glow:   '#ffd700',
    blur:   38,
    special: 'golden_boa',
  },
];

function getSnakeTier(localScore) {
  if (localScore >= 100) return SNAKE_TIERS[10]; // golden boa
  return SNAKE_TIERS[Math.floor(localScore / 10)];
}

let lastTier = -1;
let tierFlash = 0; // frames of tier-change flash
let tierLabel = '';

// ‚îÄ‚îÄ Power-up state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// ghostTime: seconds of transparency (pass through obstacles)
// invincibleTime: seconds of full invincibility (+ dragon mode)
let ghostTime = 0, invincibleTime = 0;
let ghostMax = 5, invincibleMax = 1;
const GHOST_DURATION = 5000;    // ms
const INVINCIBLE_DURATION = 1000; // ms
let ghostEndTs = 0, invincibleEndTs = 0;

const puGhost      = document.getElementById('pu-ghost');
const puInvincible = document.getElementById('pu-invincible');
const puTransBar   = document.getElementById('pu-transparent-bar');
const puInvBar     = document.getElementById('pu-invincible-bar');

function activateGhost() {
  ghostEndTs = Date.now() + GHOST_DURATION;
  puGhost.classList.add('active');
}
function activateInvincible() {
  invincibleEndTs = Date.now() + INVINCIBLE_DURATION;
  puInvincible.classList.add('active');
}
function isGhost()      { return Date.now() < ghostEndTs; }
function isInvincible() { return Date.now() < invincibleEndTs || (getSnakeTier(score).special === 'golden_boa'); }

function updatePowerupBars() {
  const now = Date.now();
  const gr = Math.max(0, ghostEndTs - now) / GHOST_DURATION;
  const ir = Math.max(0, invincibleEndTs - now) / INVINCIBLE_DURATION;
  puTransBar.style.width = (gr * 100) + '%';
  puInvBar.style.width   = (ir * 100) + '%';
  if (gr <= 0) puGhost.classList.remove('active');
  if (ir <= 0 && getSnakeTier(score).special !== 'golden_boa') puInvincible.classList.remove('active');
  // golden boa always shows invincible bar as full + pulsing
  if (getSnakeTier(score).special === 'golden_boa') {
    puInvincible.classList.add('active');
    puInvBar.style.width = '100%';
  }
}
// ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ

function playTierUp(special) {
  const ac = getAC();
  let freqs, wave, dur, vol, spacing;
  if (special === 'golden_boa') {
    // Royal golden fanfare ‚Äî majestic ascending
    freqs = [392,523,659,784,1047,1319,1568,2093];
    wave = 'sine'; dur = 0.4; vol = 0.18; spacing = 0.1;
    // extra low boom
    [100,150].forEach((f,i) => {
      const o=ac.createOscillator(), g=ac.createGain();
      o.type='sawtooth'; o.frequency.value=f;
      const t=ac.currentTime+i*0.08;
      g.gain.setValueAtTime(0.12,t); g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
      o.connect(g); g.connect(ac.destination); o.start(t); o.stop(t+0.3);
    });
  } else {
    freqs = [400,500,600,800];
    wave = 'square'; dur = 0.15; vol = 0.12; spacing = 0.07;
  }
  freqs.forEach((freq,i) => {
    const osc = ac.createOscillator(), g = ac.createGain();
    osc.type = wave; osc.frequency.value = freq;
    const t = ac.currentTime + i * spacing;
    g.gain.setValueAtTime(vol, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + dur);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t + dur);
  });
}

function showTierBanner(name, special) {
  const el = document.getElementById('tier-banner');
  if (special === 'golden_boa') {
    el.textContent = 'üêç GOLDEN BOA üêç';
    el.style.color = '#ffd700';
    el.style.textShadow = '0 0 14px #ffd700, 0 0 40px #ffaa0080, 0 0 80px #ffd70040, 0 0 120px #ff880020';
    el.style.fontSize = '22px';
    el.style.letterSpacing = '5px';
  } else {
    el.textContent = `// ${name}`;
    el.style.color = 'var(--neon-cyan)';
    el.style.textShadow = 'var(--glow-cyan)';
    el.style.fontSize = '';
    el.style.letterSpacing = '';
  }
  el.classList.remove('show');
  void el.offsetWidth;
  el.classList.add('show');
}

// ‚îÄ‚îÄ Game state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const scoreEl      = document.getElementById('score');
const overlay      = document.getElementById('overlay');
const overlaySub   = document.getElementById('overlay-sub');
const startBtn     = document.getElementById('start-btn');
const finalScoreEl = document.getElementById('final-score');
const finalVal     = document.getElementById('final-val');
const levelClear   = document.getElementById('level-clear');
const lcTitle      = document.getElementById('lc-title');
const lcSub        = document.getElementById('lc-sub');
const lcNextBtn    = document.getElementById('lc-next-btn');
const levelLabel   = document.getElementById('level-label');
const levelNum     = document.getElementById('level-num');
const goalProgress = document.getElementById('goal-progress');
const livesWrap    = document.getElementById('lives-wrap');

// ‚îÄ‚îÄ Level definitions ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Each level: { name, obstacles(COLS,ROWS) => [{x,y},...], speed }
const LEVELS = [
  { name:'AWAKENING',  obstacles:()=>[], speed:130 },
  { name:'GRID ECHO',  obstacles:(C,R)=>border4corners(C,R,3), speed:125 },
  { name:'STATIC',     obstacles:(C,R)=>crossWalls(C,R,3), speed:122 },       // LV3 ‚Äî was 4, 120
  { name:'LABYRINTH',  obstacles:(C,R)=>[...crossWalls(C,R,3),...boxes(C,R,1)], speed:118 }, // LV4
  { name:'FRACTURE',   obstacles:(C,R)=>[...crossWalls(C,R,4),...zigzag(C,R,1)], speed:114 },// LV5
  { name:'VORTEX',     obstacles:(C,R)=>[...crossWalls(C,R,4),...zigzag(C,R,1),...boxes(C,R,2)], speed:110 }, // LV6
  { name:'NEXUS',      obstacles:(C,R)=>[...crossWalls(C,R,5),...zigzag(C,R,2),...boxes(C,R,2)], speed:106 }, // LV7
  { name:'PURGATORY',  obstacles:(C,R)=>[...crossWalls(C,R,5),...zigzag(C,R,2),...boxes(C,R,3)], speed:102 }, // LV8
  { name:'PHANTOM',    obstacles:(C,R)=>[...crossWalls(C,R,6),...zigzag(C,R,3),...boxes(C,R,3)], speed:98 },  // LV9
  { name:'OBLIVION',   obstacles:(C,R)=>[...crossWalls(C,R,7),...zigzag(C,R,3),...boxes(C,R,4)], speed:94 }, // LV10
];
const GOAL_PER_LEVEL = 120;
const MAX_LIVES = 5;

// ‚îÄ‚îÄ Food types ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const FOOD_TYPES = [
  { type:'white',  prob:0.40, points:1,       color:'#ffffff', glow:'#ffffff', glowRgb:'255,255,255', label:'+1' },
  { type:'green',  prob:0.30, points:2,       color:'#39ff14', glow:'#39ff14', glowRgb:'57,255,20',   label:'+2' },
  { type:'yellow', prob:0.15, points:5,       color:'#ffe600', glow:'#ffe600', glowRgb:'255,230,0',   label:'+5' },
  { type:'red',    prob:0.15, points:null,    color:'#ff2d78', glow:'#ff2d78', glowRgb:'255,45,120',  label:'??' },
];
function randomFoodType() {
  const r = Math.random();
  let acc = 0;
  for (const t of FOOD_TYPES) { acc += t.prob; if (r < acc) return t; }
  return FOOD_TYPES[0];
}

// obstacle generators
function border4corners(C,R,len) {
  const obs=[];
  for(let i=0;i<len;i++) {
    obs.push({x:i,y:0},{x:i,y:R-1},{x:C-1-i,y:0},{x:C-1-i,y:R-1});
    obs.push({x:0,y:i},{x:C-1,y:i},{x:0,y:R-1-i},{x:C-1,y:R-1-i});
  }
  return dedup(obs);
}
function crossWalls(C,R,count) {
  const obs=[], mid=Math.floor(R/2), midc=Math.floor(C/2);
  for(let k=0;k<count;k++) {
    const gap=3, y=Math.floor(R*(k+1)/(count+1));
    const even=k%2===0;
    for(let x=0;x<C;x++) {
      if(even && Math.abs(x-midc)>gap) obs.push({x,y});
      if(!even && Math.abs(x-midc)<=C/2-gap) obs.push({x,y});
    }
  }
  return dedup(obs);
}
function zigzag(C,R,count) {
  const obs=[];
  for(let k=0;k<count;k++) {
    const x0=Math.floor(C*(k+1)/(count+1));
    const dir2=k%2===0?1:-1;
    for(let seg=0;seg<4;seg++) {
      const y=Math.floor(R/4*seg);
      const len=Math.floor(R/5);
      const x=x0+(seg%2===0?0:3)*dir2;
      for(let j=0;j<len;j++) obs.push({x:Math.min(C-1,Math.max(0,x)),y:Math.min(R-1,y+j)});
    }
  }
  return dedup(obs);
}
function boxes(C,R,count) {
  const obs=[];
  const positions=[
    {x:Math.floor(C*0.25),y:Math.floor(R*0.25)},
    {x:Math.floor(C*0.75),y:Math.floor(R*0.25)},
    {x:Math.floor(C*0.25),y:Math.floor(R*0.75)},
    {x:Math.floor(C*0.75),y:Math.floor(R*0.75)},
    {x:Math.floor(C*0.5), y:Math.floor(R*0.5)},
    {x:Math.floor(C*0.5), y:Math.floor(R*0.2)},
    {x:Math.floor(C*0.5), y:Math.floor(R*0.8)},
  ];
  for(let k=0;k<Math.min(count,positions.length);k++) {
    const {x,y}=positions[k];
    for(let dx=-1;dx<=1;dx++) for(let dy=-1;dy<=1;dy++) {
      if(dx===0&&dy===0) continue;
      const nx=x+dx, ny=y+dy;
      if(nx>=0&&nx<C&&ny>=0&&ny<R) obs.push({x:nx,y:ny});
    }
  }
  return dedup(obs);
}
function dedup(arr) {
  const seen=new Set(); 
  return arr.filter(o=>{const k=o.x+','+o.y; if(seen.has(k))return false; seen.add(k); return true;});
}

// ‚îÄ‚îÄ Game state ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let snake, dir, nextDir, foods, obstacles, score, levelScore, lives, currentLevel;
let gameLoop, alive;
let eatFlash = 0, deathShake = 0, foodPulse = 0;
let raf;

function buildLevel(lvlIdx) {
  currentLevel = lvlIdx;
  const lv = LEVELS[lvlIdx];
  obstacles = lv.obstacles(COLS, ROWS);
  // clear safe zone around start
  const mid=Math.floor(COLS/2);
  obstacles = obstacles.filter(o=>!(Math.abs(o.x-mid)<=3&&Math.abs(o.y-mid)<=3));
  updateHUD();
}

function updateHUD() {
  const lv=currentLevel+1;
  levelLabel.textContent='LV.'+String(lv).padStart(2,'0')+' // '+LEVELS[currentLevel].name;
  levelNum.textContent=String(lv).padStart(2,'0');
  goalProgress.textContent=String(levelScore).padStart(3,'0')+'/120';
  // hearts
  livesWrap.innerHTML='';
  for(let i=0;i<MAX_LIVES;i++){
    const h=document.createElement('span');
    h.className='heart'+(i>=lives?' lost':'');
    h.textContent='‚ô•';
    livesWrap.appendChild(h);
  }
}

function initSnake() {
  const mid=Math.floor(COLS/2);
  snake=[{x:mid,y:mid},{x:mid-1,y:mid},{x:mid-2,y:mid}];
  dir={x:1,y:0}; nextDir={x:1,y:0};
}

function initLevel(lvlIdx, resetLives) {
  buildLevel(lvlIdx);
  if(resetLives) { lives=MAX_LIVES; score=0; }
  levelScore=0;
  alive=true;
  lastTier=-1; tierFlash=0;
  eatFlash=0; deathShake=0; foodPulse=0;
  // reset tier color cycle each level
  score = resetLives ? 0 : score;
  scoreEl.textContent=String(score).padStart(3,'0');
  eatParticles=[];
  scoreLabels=[];
  foods=[];
  // reset power-ups
  ghostEndTs=0; invincibleEndTs=0;
  puGhost.classList.remove('active');
  puInvincible.classList.remove('active');
  initSnake();
  spawnFoods();
  updateHUD();
}

function spawnFoods() {
  const count=Math.floor(Math.random()*4)+2; // 2-5
  while(foods.length<count) {
    let pos,attempts=0;
    do {
      pos={x:Math.floor(Math.random()*COLS),y:Math.floor(Math.random()*ROWS)};
      attempts++;
    } while(attempts<200&&(
      snake.some(s=>s.x===pos.x&&s.y===pos.y)||
      foods.some(f=>f.x===pos.x&&f.y===pos.y)||
      obstacles.some(o=>o.x===pos.x&&o.y===pos.y)
    ));
    if(attempts<200) { const ft=randomFoodType(); foods.push({x:pos.x,y:pos.y,pulse:Math.random()*Math.PI*2,ft}); }
  }
}

function applyDir(d) {
  if (!alive || paused) return;
  if (d.x===-dir.x && d.y===-dir.y) return;
  nextDir = d;
}

const SPEED = 120;

function gameRaf(ts) {
  if (!alive && deathShake <= 0) return;
  raf = requestAnimationFrame(gameRaf);
  foodPulse += 0.08;
  foods.forEach(f=>f.pulse+=0.07);
  if (deathShake > 0) deathShake--;
  draw();
}

function update() {
  if (!alive) return;
  updatePowerupBars();
  dir = nextDir;
  const raw = {x: snake[0].x+dir.x, y: snake[0].y+dir.y};
  const head = {x: ((raw.x % COLS) + COLS) % COLS, y: ((raw.y % ROWS) + ROWS) % ROWS};

  const inv = isInvincible();
  const gho = isGhost();

  // self collision ‚Äî only if not invincible
  if (!inv && snake.some(s=>s.x===head.x&&s.y===head.y)) return die();

  // obstacle collision
  const obsIdx = obstacles.findIndex(o=>o.x===head.x&&o.y===head.y);
  if (obsIdx !== -1) {
    if (inv) {
      // DRAGON: smash obstacle with particles
      const obs = obstacles.splice(obsIdx, 1)[0];
      spawnEatParticles(obs.x*CELL+CELL/2, obs.y*CELL+CELL/2, '255,100,0');
      playSmash();
    } else if (gho) {
      // ghost: pass through silently (do nothing)
    } else {
      return die();
    }
  }

  snake.unshift(head);

  // check food
  const fi = foods.findIndex(f=>f.x===head.x&&f.y===head.y);
  if (fi!==-1) {
    const eaten = foods.splice(fi,1)[0];
    const ft = eaten.ft;
    const pts = ft.points !== null ? ft.points : (Math.floor(Math.random()*8)+1);
    score += pts; levelScore += pts;
    const s = String(score).padStart(3,'0');
    scoreEl.textContent = s;
    scoreEl.classList.add('pop');
    setTimeout(()=>scoreEl.classList.remove('pop'),150);
    eatFlash = 6;
    playEat();
    spawnEatParticles(head.x*CELL+CELL/2, head.y*CELL+CELL/2, ft.glowRgb);
    spawnScoreLabel(head.x*CELL+CELL/2, head.y*CELL, pts, ft.color);
    // red food: grant 1s invincible
    if (ft.type === 'red') {
      activateInvincible();
      showTierBanner('INVINCIBLE', false);
    }
    // tier change? (based on score within current level cycle)
    const newTierIdx = score>=100 ? 10 : Math.floor(score/10);
    if (newTierIdx !== lastTier) {
      lastTier = newTierIdx;
      const tier = SNAKE_TIERS[newTierIdx];
      tierFlash = 30;
      tierLabel = tier.name;
      playTierUp(tier.special);
      showTierBanner(tier.name, tier.special);
    }
    // level clear check
    if (levelScore >= GOAL_PER_LEVEL) return levelClearScreen();
    // replenish food
    setTimeout(spawnFoods, 300);
    updateHUD();
  } else {
    snake.pop();
  }
}

// eat particles (on game canvas, drawn per frame for N frames)
let eatParticles = [];
function spawnEatParticles(cx, cy, rgb='255,45,120') {
  for (let i=0; i<12; i++) {
    const angle = Math.random()*Math.PI*2;
    const speed = Math.random()*3+1;
    eatParticles.push({
      x:cx, y:cy,
      vx: Math.cos(angle)*speed, vy: Math.sin(angle)*speed,
      life: 1, decay: 0.055+Math.random()*0.04,
      r: Math.random()*2.5+1,
      rgb
    });
  }
}

// floating score labels
let scoreLabels = [];
function spawnScoreLabel(cx, cy, pts, color) {
  scoreLabels.push({ x:cx, y:cy, pts, color, life:1, vy:-1.2 });
}

function draw() {
  const W = canvas.width, H = canvas.height;

  // shake on death
  let sx=0, sy=0;
  if (deathShake>0) { sx=(Math.random()-0.5)*8; sy=(Math.random()-0.5)*8; }

  ctx.save();
  ctx.translate(sx, sy);

  // background
  ctx.fillStyle = '#030810';
  ctx.fillRect(-10,-10,W+20,H+20);

  // grid lines
  ctx.lineWidth = 0.5;
  ctx.strokeStyle = 'rgba(0,255,231,0.05)';
  for (let x=0;x<=COLS;x++) {
    ctx.beginPath(); ctx.moveTo(x*CELL,0); ctx.lineTo(x*CELL,H); ctx.stroke();
  }
  for (let y=0;y<=ROWS;y++) {
    ctx.beginPath(); ctx.moveTo(0,y*CELL); ctx.lineTo(W,y*CELL); ctx.stroke();
  }

  // eat flash overlay
  if (eatFlash>0) {
    ctx.fillStyle = `rgba(0,255,231,${eatFlash*0.015})`;
    ctx.fillRect(0,0,W,H);
    eatFlash--;
  }

  // obstacles ‚Äî solid, glowing blocks
  if (obstacles.length > 0) {
    ctx.shadowColor = 'rgba(0,255,231,0.7)';
    ctx.shadowBlur = 6;
    obstacles.forEach(o=>{
      const ox=o.x*CELL, oy=o.y*CELL;
      // solid fill ‚Äî deep teal-blue
      ctx.fillStyle='#0e2a2a';
      ctx.fillRect(ox,oy,CELL,CELL);
      // bright top/left edge highlight
      ctx.fillStyle='rgba(0,255,231,0.55)';
      ctx.fillRect(ox, oy, CELL, 2);       // top
      ctx.fillRect(ox, oy, 2, CELL);       // left
      // darker bottom/right
      ctx.fillStyle='rgba(0,80,70,0.8)';
      ctx.fillRect(ox, oy+CELL-2, CELL, 2); // bottom
      ctx.fillRect(ox+CELL-2, oy, 2, CELL); // right
      // center dot
      ctx.fillStyle='rgba(0,255,231,0.25)';
      const cd=3;
      ctx.fillRect(ox+CELL/2-cd/2, oy+CELL/2-cd/2, cd, cd);
    });
    ctx.shadowBlur = 0;
  }

  // foods ‚Äî color by type, larger radius for readability
  foods.forEach(food=>{
    const ft = food.ft;
    const rgb = ft.glowRgb;
    const isRed = ft.type==='red';
    const r = CELL * 0.72 + Math.sin(food.pulse) * 1.8; // big, cell-filling
    const fx = food.x*CELL+CELL/2, fy = food.y*CELL+CELL/2;
    // wide outer glow
    const grad = ctx.createRadialGradient(fx,fy,0,fx,fy,r*2.2);
    grad.addColorStop(0, `rgba(${rgb},0.6)`);
    grad.addColorStop(0.45, `rgba(${rgb},0.18)`);
    grad.addColorStop(1, `rgba(${rgb},0)`);
    ctx.fillStyle = grad;
    ctx.beginPath(); ctx.arc(fx,fy,r*2.2,0,Math.PI*2); ctx.fill();
    // solid core circle
    ctx.shadowColor = ft.glow; ctx.shadowBlur = isRed ? 26 : 20;
    ctx.fillStyle = ft.color;
    ctx.beginPath(); ctx.arc(fx,fy,r,0,Math.PI*2); ctx.fill();
    // subtle dark rim for contrast
    ctx.shadowBlur = 0;
    ctx.strokeStyle = 'rgba(0,0,0,0.35)';
    ctx.lineWidth = 1.2;
    ctx.stroke();
    // white inner highlight arc
    ctx.fillStyle = 'rgba(255,255,255,0.65)';
    ctx.beginPath(); ctx.arc(fx-r*0.22,fy-r*0.22,r*0.28,0,Math.PI*2); ctx.fill();
    // score label ‚Äî big and clear
    const fontSize = Math.round(r * 0.92);
    ctx.font = `900 ${fontSize}px Orbitron, monospace`;
    ctx.textAlign = 'center';
    ctx.textBaseline = 'middle';
    // text shadow for legibility
    ctx.fillStyle = 'rgba(0,0,0,0.55)';
    ctx.fillText(isRed ? '?' : ft.label, fx+1, fy+1);
    ctx.fillStyle = isRed ? '#ffffff' : (ft.type==='white' ? '#000000' : '#ffffff');
    ctx.fillText(isRed ? '?' : ft.label, fx, fy);
    ctx.textBaseline = 'alphabetic';
    ctx.textAlign = 'left';
  });

  // eat particles
  eatParticles = eatParticles.filter(p=>p.life>0);
  eatParticles.forEach(p=>{
    p.x+=p.vx; p.y+=p.vy; p.vy+=0.12; p.life-=p.decay;
    ctx.globalAlpha = p.life;
    ctx.fillStyle = `rgba(${p.rgb},1)`;
    ctx.shadowColor = `rgba(${p.rgb},1)`; ctx.shadowBlur = 8;
    ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    ctx.shadowBlur=0;
  });

  // floating score labels
  scoreLabels = scoreLabels.filter(l=>l.life>0);
  scoreLabels.forEach(l=>{
    l.y += l.vy; l.life -= 0.025;
    ctx.globalAlpha = Math.min(l.life*3, 1);
    ctx.fillStyle = l.color;
    ctx.shadowColor = l.color; ctx.shadowBlur = 10;
    ctx.font = `bold ${Math.round(CELL*0.9)}px Orbitron, monospace`;
    ctx.textAlign = 'center';
    ctx.fillText((l.pts>0?'+':'')+l.pts, l.x, l.y);
    ctx.shadowBlur = 0;
  });
  ctx.textAlign = 'left';
  ctx.globalAlpha=1;

  // snake ‚Äî tier-aware rendering
  const tier = getSnakeTier(score);
  const inv = isInvincible();
  const gho = isGhost();

  // tier flash overlay
  if (tierFlash > 0) {
    const tf = tierFlash / 30;
    if (tier.special === 'golden_boa')
      ctx.fillStyle = `rgba(255,200,0,${tf*0.22})`;
    // (golden_boa is the only special now)
    else
      ctx.fillStyle = `rgba(0,255,231,${tf*0.12})`;
    ctx.fillRect(0,0,W,H);
    tierFlash--;
  }

  // invincible pulse border overlay
  if (inv) {
    const p = 0.5 + 0.5*Math.sin(Date.now()/80);
    ctx.strokeStyle = `rgba(255,215,0,${0.5+p*0.4})`;
    ctx.lineWidth = 3;
    ctx.shadowColor = '#ffd700'; ctx.shadowBlur = 16;
    ctx.strokeRect(3,3,W-6,H-6);
    ctx.shadowBlur=0;
  }

  // ghost overlay ‚Äî blue tint on canvas
  if (gho) {
    const gp = 0.4 + 0.3*Math.sin(Date.now()/200);
    ctx.fillStyle = `rgba(100,200,255,${gp*0.06})`;
    ctx.fillRect(0,0,W,H);
  }

  // golden boa mode ‚Äî shimmering gold vignette
  if (tier.special === 'golden_boa') {
    const dp = 0.5 + 0.5*Math.sin(Date.now()/200);
    const dg = ctx.createRadialGradient(W/2,H/2,W*0.15,W/2,H/2,W*0.72);
    dg.addColorStop(0, 'rgba(0,0,0,0)');
    dg.addColorStop(0.6, `rgba(180,120,0,${dp*0.08})`);
    dg.addColorStop(1, `rgba(255,180,0,${dp*0.22})`);
    ctx.fillStyle = dg;
    ctx.fillRect(0,0,W,H);
    // golden sparkle particles on border
    const now2 = Date.now();
    for (let sp=0; sp<6; sp++) {
      const ang = (now2/600 + sp/6) * Math.PI*2;
      const rx = W/2 + (W/2-4)*Math.cos(ang), ry = H/2 + (H/2-4)*Math.sin(ang);
      const alpha = 0.4 + 0.4*Math.sin(now2/150 + sp);
      ctx.beginPath(); ctx.arc(rx, ry, 3, 0, Math.PI*2);
      ctx.fillStyle = `rgba(255,215,0,${alpha})`;
      ctx.shadowColor='#ffd700'; ctx.shadowBlur=10;
      ctx.fill();
    }
    ctx.shadowBlur=0;
  }

  snake.forEach((seg,i) => {
    const t = i/Math.max(snake.length,1);
    const isHead = i===0;
    const pad = isHead ? 1 : 2;
    const bx = seg.x*CELL+pad, by = seg.y*CELL+pad;
    const bw = CELL-pad*2, bh = CELL-pad*2;

    // ghost mode: semi-transparent blue-white
    if (gho) {
      ctx.globalAlpha = 0.45 - t*0.2;
      ctx.shadowColor = '#64c8ff'; ctx.shadowBlur = isHead ? 18 : 8;
      ctx.fillStyle = isHead ? '#a0e8ff' : `rgba(100,200,255,${0.8-t*0.4})`;
      ctx.fillRect(bx,by,bw,bh);
      if (isHead) {
        ctx.shadowBlur=0; ctx.globalAlpha=0.6;
        ctx.fillStyle='rgba(255,255,255,0.5)';
        ctx.fillRect(bx+2,by+2,bw*0.45,bh*0.3);
      }
      ctx.globalAlpha=1; ctx.shadowBlur=0;
      return;
    }

    // golden boa mode ‚Äî spectacular shimmering scales
    if (tier.special === 'golden_boa') {
      const shimmer = Math.sin(Date.now()/250 + i*0.5) * 0.5 + 0.5;
      const pulse   = Math.sin(Date.now()/180 + i*0.3) * 0.5 + 0.5;
      const even    = Math.floor(i/2)%2===0;
      const r = even ? 255 : Math.round(200 + shimmer*30);
      const g = even ? Math.round(165 + shimmer*50) : Math.round(100 + shimmer*40);
      const b = even ? 0 : 0;
      ctx.shadowColor = even ? `rgba(255,215,0,${0.6+pulse*0.4})` : '#b8860b';
      ctx.shadowBlur  = isHead ? 28 : (even ? 10 : 6);
      ctx.fillStyle = `rgba(${r},${g},${b},${1-t*0.3})`;
      ctx.fillRect(bx,by,bw,bh);
      // shimmering scale highlight
      if (even) {
        ctx.globalAlpha = 0.25 + shimmer*0.35;
        ctx.fillStyle = `rgba(255,255,200,1)`;
        ctx.fillRect(bx+1, by+1, bw*0.55, bh*0.42);
        ctx.globalAlpha = 1;
      }
      // scale border lines
      ctx.strokeStyle = `rgba(180,120,0,0.5)`;
      ctx.lineWidth = 0.7;
      ctx.beginPath();
      ctx.moveTo(bx, by+bh/2); ctx.lineTo(bx+bw, by+bh/2);
      ctx.stroke();
      if (isHead) {
        ctx.shadowBlur=0;
        ctx.fillStyle='rgba(255,255,200,0.4)';
        ctx.fillRect(bx+2,by+2,bw*0.5,bh*0.35);
        // golden eyes
        ctx.fillStyle='#00ffff'; ctx.shadowColor='#00ffff'; ctx.shadowBlur=8;
        ctx.beginPath(); ctx.arc(bx+bw*0.28, by+bh*0.35, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.beginPath(); ctx.arc(bx+bw*0.72, by+bh*0.35, 2.5, 0, Math.PI*2); ctx.fill();
        ctx.shadowBlur=0;
      }
      return;
    }

    // golden boa (fallback, should not be reached)
    if (tier.special === 'golden_boa_fallback') {
      const scaleColor = Math.floor(i/2)%2===0 ? '#ffd700' : '#b8860b';
      ctx.fillStyle = scaleColor;
      ctx.shadowColor = '#ffd700';
      ctx.shadowBlur = isHead ? 30 : 12;
      ctx.fillRect(bx,by,bw,bh);
      ctx.globalAlpha = 0.35;
      ctx.fillStyle = '#fffacd';
      ctx.fillRect(bx+1,by+1,bw*0.5,bh*0.4);
      ctx.globalAlpha = 1;
      if (isHead) {
        ctx.shadowBlur=0;
        ctx.fillStyle='rgba(255,255,220,0.45)';
        ctx.fillRect(bx+2,by+2,bw*0.45,bh*0.3);
      }
      return;
    }

    // normal tier
    const color = isHead ? tier.head() : tier.body(t, i);
    ctx.shadowColor = tier.glow;
    ctx.shadowBlur = isHead ? tier.blur : tier.blur*0.4;
    ctx.fillStyle = color;
    ctx.fillRect(bx,by,bw,bh);
    if (isHead) {
      ctx.shadowBlur=0;
      ctx.fillStyle='rgba(255,255,255,0.25)';
      ctx.fillRect(bx+2,by+2,bw*0.45,bh*0.3);
    }
  });
  ctx.shadowBlur=0;
  ctx.restore();
}

function playSmash() {
  const ac = getAC();
  [300, 200, 150, 80].forEach((freq, i) => {
    const osc = ac.createOscillator(), g = ac.createGain();
    osc.type = 'sawtooth'; osc.frequency.value = freq;
    const t = ac.currentTime + i * 0.03;
    g.gain.setValueAtTime(0.14, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.08);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t + 0.08);
  });
}

function playGhostActivate() {
  const ac = getAC();
  [800, 1000, 1200, 1000, 800].forEach((freq, i) => {
    const osc = ac.createOscillator(), g = ac.createGain();
    osc.type = 'sine'; osc.frequency.value = freq;
    const t = ac.currentTime + i * 0.08;
    g.gain.setValueAtTime(0.1, t);
    g.gain.exponentialRampToValueAtTime(0.001, t + 0.12);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t + 0.12);
  });
}

function playLevelClear() {
  const ac=getAC();
  [523,659,784,880,1047,1319].forEach((freq,i)=>{
    const osc=ac.createOscillator(),g=ac.createGain();
    osc.type='sine'; osc.frequency.value=freq;
    const t=ac.currentTime+i*0.12;
    g.gain.setValueAtTime(0.15,t);
    g.gain.exponentialRampToValueAtTime(0.001,t+0.3);
    osc.connect(g); g.connect(ac.destination);
    osc.start(t); osc.stop(t+0.3);
  });
}

function levelClearScreen() {
  alive=false;
  clearInterval(gameLoop);
  playLevelClear();
  // clear power-ups from previous level
  ghostEndTs=0; invincibleEndTs=0;
  puGhost.classList.remove('active');
  puInvincible.classList.remove('active');
  const nextLv=currentLevel+1;
  if(nextLv>=LEVELS.length) {
    // beat all levels
    lcTitle.textContent='üèÜ ALL CLEAR üèÜ';
    lcSub.textContent='// YOU CONQUERED THE MATRIX';
    lcNextBtn.textContent='[ PLAY AGAIN ]';
    lcNextBtn.dataset.action='reset';
  } else {
    lcTitle.textContent='STAGE CLEAR';
    lcSub.textContent='// ENTERING '+LEVELS[nextLv].name;
    lcNextBtn.textContent='[ NEXT STAGE ]';
    lcNextBtn.dataset.action='next';
  }
  setTimeout(()=>levelClear.classList.add('show'), 400);
}

function die() {
  alive = false;
  clearInterval(gameLoop);
  deathShake = 20;
  playDie();
  lives--;
  // clear power-ups on death
  ghostEndTs = 0; invincibleEndTs = 0;
  puGhost.classList.remove('active');
  puInvincible.classList.remove('active');
  raf = requestAnimationFrame(gameRaf);
  updateHUD();
  setTimeout(()=>{
    if(lives<=0) {
      // game over
      finalVal.textContent = score;
      finalScoreEl.style.display = 'block';
      overlaySub.textContent='// LV.'+String(currentLevel+1).padStart(2,'0')+' ‚Äî '+LEVELS[currentLevel].name;
      startBtn.textContent = '[ RETRY ]';
      overlay.style.display = 'flex';
    } else {
      // respawn on same level ‚Äî grant 5s ghost
      initSnake();
      spawnFoods();
      alive=true;
      eatParticles=[];
      activateGhost();
      playGhostActivate();
      showTierBanner('üëª GHOST MODE', false);
      clearInterval(gameLoop);
      gameLoop=setInterval(update, LEVELS[currentLevel].speed);
    }
  }, 800);
}

function startGame(lvlIdx, resetLives) {
  resumeAC();
  paused = false;
  setPauseIcon(false);
  overlay.style.display='none';
  levelClear.classList.remove('show');
  cancelAnimationFrame(raf);
  clearInterval(gameLoop);
  initLevel(lvlIdx, resetLives);
  draw();
  startBGM(lvlIdx);
  raf=requestAnimationFrame(gameRaf);
  gameLoop=setInterval(update, LEVELS[lvlIdx].speed);
}

startBtn.addEventListener('click', ()=>startGame(0, true));

lcNextBtn.addEventListener('click', ()=>{
  if(lcNextBtn.dataset.action==='reset') startGame(0, true);
  else startGame(currentLevel+1, false);
});

// ‚îÄ‚îÄ Keyboard ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Escape') return; // handled by pause listener
  const map = {
    ArrowUp:{x:0,y:-1}, ArrowDown:{x:0,y:1}, ArrowLeft:{x:-1,y:0}, ArrowRight:{x:1,y:0},
    w:{x:0,y:-1}, s:{x:0,y:1}, a:{x:-1,y:0}, d:{x:1,y:0},
    W:{x:0,y:-1}, S:{x:0,y:1}, A:{x:-1,y:0}, D:{x:1,y:0},
  };
  const dir = map[e.key]; if (!dir) return;
  e.preventDefault(); applyDir(dir);
});

// ‚îÄ‚îÄ Pause ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let paused = false;
const pauseBtn   = document.getElementById('pause-btn');
const pauseIcon  = document.getElementById('pause-icon');
const pauseLabel = document.getElementById('pause-label');

// pause icon SVGs
const SVG_PAUSE = '<rect x="6" y="5" width="4" height="14" rx="1"/><rect x="14" y="5" width="4" height="14" rx="1"/>';
const SVG_PLAY  = '<path d="M7 4l13 8-13 8V4z"/>';

function setPauseIcon(isPaused) {
  pauseIcon.innerHTML = isPaused ? SVG_PLAY : SVG_PAUSE;
  pauseLabel.textContent = isPaused ? 'PLAY' : 'PAUSE';
}

function togglePause() {
  if (!alive) return;
  resumeAC();
  paused = !paused;
  setPauseIcon(paused);
  if (paused) {
    clearInterval(gameLoop);
    cancelAnimationFrame(raf);
    stopBGM();
    drawPauseOverlay();
  } else {
    startBGM(currentLevel);
    gameLoop = setInterval(update, LEVELS[currentLevel].speed);
    raf = requestAnimationFrame(gameRaf);
  }
}

function drawPauseOverlay() {
  const W = canvas.width, H = canvas.height;
  ctx.save();
  ctx.fillStyle = 'rgba(3,8,16,0.75)';
  ctx.fillRect(0,0,W,H);
  ctx.font = '900 22px Orbitron, monospace';
  ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
  ctx.fillStyle = 'var(--neon-yellow, #ffe600)';
  ctx.shadowColor = '#ffe600'; ctx.shadowBlur = 18;
  ctx.fillText('// PAUSED', W/2, H/2 - 14);
  ctx.shadowBlur = 0;
  ctx.font = '10px Orbitron, monospace';
  ctx.fillStyle = 'rgba(0,255,231,0.5)';
  ctx.fillText('TAP ‚ñ∂ TO CONTINUE', W/2, H/2 + 18);
  ctx.textAlign = 'left'; ctx.textBaseline = 'alphabetic';
  ctx.restore();
}

pauseBtn.addEventListener('touchstart', e=>{e.preventDefault(); pauseBtn.classList.add('pressed'); togglePause();},{passive:false});
pauseBtn.addEventListener('touchend',   e=>{e.preventDefault(); pauseBtn.classList.remove('pressed');},{passive:false});
pauseBtn.addEventListener('mousedown', ()=>{pauseBtn.classList.add('pressed'); togglePause();});
pauseBtn.addEventListener('mouseup',   ()=>pauseBtn.classList.remove('pressed'));

// Space key to pause
document.addEventListener('keydown', e => {
  if (e.key === ' ' || e.key === 'Escape') { e.preventDefault(); togglePause(); }
});

// ‚îÄ‚îÄ D-pad button listeners ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
const DMAP2 = {up:{x:0,y:-1},down:{x:0,y:1},left:{x:-1,y:0},right:{x:1,y:0}};
['dp-up','dp-down','dp-left','dp-right'].forEach(id => {
  const btn = document.getElementById(id);
  if (!btn) return;
  const dirKey = id.replace('dp-','');
  const press   = () => { resumeAC(); if (!paused) applyDir(DMAP2[dirKey]); btn.classList.add('pressed'); };
  const release = () => btn.classList.remove('pressed');
  btn.addEventListener('touchstart', e=>{ e.preventDefault(); press(); }, {passive:false});
  btn.addEventListener('touchend',   e=>{ e.preventDefault(); release(); }, {passive:false});
  btn.addEventListener('mousedown',  press);
  btn.addEventListener('mouseup',    release);
  btn.addEventListener('mouseleave', release);
});

// ‚îÄ‚îÄ Touch controls: swipe + tap-relative-to-snake-head ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
let tx=0, ty=0, tMoved=false;

canvas.addEventListener('touchstart', e=>{
  e.preventDefault();
  tx = e.touches[0].clientX;
  ty = e.touches[0].clientY;
  tMoved = false;
},{passive:false});

canvas.addEventListener('touchmove', e=>{
  e.preventDefault();
  // mark as swipe if finger moved enough
  const dx = e.touches[0].clientX - tx;
  const dy = e.touches[0].clientY - ty;
  if (Math.abs(dx) > 8 || Math.abs(dy) > 8) tMoved = true;
},{passive:false});

canvas.addEventListener('touchend', e=>{
  e.preventDefault();
  resumeAC();
  const ex = e.changedTouches[0].clientX;
  const ey = e.changedTouches[0].clientY;
  const dx = ex - tx, dy = ey - ty;

  if (tMoved || Math.abs(dx) > 10 || Math.abs(dy) > 10) {
    // ‚îÄ‚îÄ Swipe gesture ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    applyDir(Math.abs(dx) > Math.abs(dy)
      ? (dx > 0 ? {x:1,y:0} : {x:-1,y:0})
      : (dy > 0 ? {x:0,y:1} : {x:0,y:-1}));
  } else {
    // ‚îÄ‚îÄ Tap: determine direction relative to snake head on canvas ‚îÄ‚îÄ
    if (!alive || paused || snake.length === 0) return;
    const rect = canvas.getBoundingClientRect();
    // tap position in canvas coordinates
    const tapX = (ex - rect.left) * (canvas.width  / rect.width);
    const tapY = (ey - rect.top)  * (canvas.height / rect.height);
    // snake head position in canvas coordinates
    const headX = snake[0].x * CELL + CELL / 2;
    const headY = snake[0].y * CELL + CELL / 2;
    const relX = tapX - headX;
    const relY = tapY - headY;
    // choose axis with larger offset, then pick direction
    // but never allow reversing current direction
    let newDir;
    if (Math.abs(relX) >= Math.abs(relY)) {
      newDir = relX > 0 ? {x:1,y:0} : {x:-1,y:0};
    } else {
      newDir = relY > 0 ? {x:0,y:1} : {x:0,y:-1};
    }
    // ignore if it would reverse (applyDir already blocks 180, but be explicit)
    if (newDir.x === -dir.x && newDir.y === -dir.y) return;
    // ignore if already going that direction
    if (newDir.x === dir.x && newDir.y === dir.y) return;
    applyDir(newDir);
  }
},{passive:false});

document.addEventListener('touchmove', e=>e.preventDefault(), {passive:false});

// ‚îÄ‚îÄ Init ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
// Initialize with level 1 defaults (won't render until start clicked)
currentLevel=0; lives=MAX_LIVES; score=0; levelScore=0;
foods=[]; obstacles=[];
snake=[{x:10,y:10},{x:9,y:10},{x:8,y:10}];
ctx.fillStyle='#030810'; ctx.fillRect(0,0,canvas.width,canvas.height);
updateHUD();
</script>
</body>
</html>